// =================================================================
// File: src/commands/cat_file.cpp
// =================================================================

#include "../include/cat_file.h"
#include "../include/object_utils.h"

#include <iostream>
#include <string>
#include <vector>
#include <optional>

int handleCatFile(int argc, char* argv[]) {
    if (argc != 4 || std::string(argv[2]) != "-p") {
        std::cerr << "Usage: mygit cat-file -p <blob-sha>\n";
        return EXIT_FAILURE;
    }

    const std::string objectId = argv[3];
    auto decompressedDataOpt = readGitObject(objectId);

    if (!decompressedDataOpt) {
        std::cerr << "Fatal: Not a valid object name " << objectId << '\n';
        return EXIT_FAILURE;
    }
    
    const auto& decompressedDataVec = *decompressedDataOpt;
    std::span<const std::byte> dataSpan(decompressedDataVec);
    auto nullPosIt = findNullSeparator(dataSpan);

    if (nullPosIt == dataSpan.end()) {
        std::cerr << "Invalid Git object format (missing null separator)\n";
        return EXIT_FAILURE;
    }

    // The content is everything after the null byte.
    // We write it directly to stdout's buffer to handle binary data correctly.
    const char* contentStart = reinterpret_cast<const char*>(&*(nullPosIt + 1));
    
    // We can get the size by creating a subspan
    auto contentSpan = dataSpan.subspan(std::distance(dataSpan.begin(), nullPosIt) + 1);
    const size_t contentSize = contentSpan.size();

    std::cout.write(contentStart, contentSize);

    return EXIT_SUCCESS;
}

// =================================================================
// File: src/commands/clone.cpp
// =================================================================

#include "../include/clone.h"
#include "../include/pkt_line_utils.h"
#include "../include/packfile_utils.h"
#include "../include/object_utils.h"

#include <cpr/cpr.h>

#include <iostream>
#include <string> 
#include <vector>
#include <optional>
#include <map>


int handleClone(int argc, char* argv[]){
    std::string baseUrl;
    std::string dir;

    if (argc == 4){
        baseUrl = argv[2];
        dir = argv[3];
    }
    else if (argc == 3){
        baseUrl = argv[2];
        dir = ".";
    }
    else{
        std::cerr << "Usage: mygit clone <git-address> [<some-directory>]\n";
        return EXIT_FAILURE;
    }

    //  URL must end with .git
    if (baseUrl.rfind(".git") == std::string::npos) {
        baseUrl += ".git";
    }
    // no slash at the end
    if (baseUrl.back() == '/') {
        baseUrl.pop_back();
    }

    //1. GET REF DISCOVERY
    std::cout << "baseUrl: " << baseUrl << "\n";
    std::string discoveryUrl = baseUrl + "/info/refs?service=git-upload-pack";

    cpr::Response discoveryResp = cpr::Get(cpr::Url{discoveryUrl});

    std::cout << "Status: " << discoveryResp.status_code << "\n";
    if (discoveryResp.status_code != 200) {
        std::cerr << "Error: Failed to fetch refs.\n";
        std::cerr << "Status: " << discoveryResp.status_code << "\n";
        std::cerr << "Body:\n" << discoveryResp.text << std::endl;
        return EXIT_FAILURE;
    }

    //2. FIND MAIN BRANCH SHA
    auto sha1HexMain = findMainBranchSha1(discoveryResp.text);

    if (!sha1HexMain) {
        std::cerr << "Couldn't find the main Sha1 \n" ;
        return EXIT_FAILURE;
    }

    //3. POST REQUEST : ASK FOR PACKFILE
    std::stringstream requestBodyStream;

    // first line we want : <size>want <sha1-du-commit-main> side-band-64k\n
    std::string wantLine = "want " + *sha1HexMain + " multi_ack_detailed no-done side-band-64k agent=mygit/0.1\n";

    requestBodyStream << createPktLine(wantLine);
    requestBodyStream << createPktLine(""); // Le "flush-pkt"
    requestBodyStream << createPktLine("done\n");

    std::string postReq = requestBodyStream.str();
    std::cout << "postReq sent: " << postReq << std::endl;

    cpr::Session session;
    std::string postUrl = baseUrl + "/git-upload-pack";
    session.SetUrl(cpr::Url{postUrl});

    // header
    session.SetHeader({
        {"Content-Type", "application/x-git-upload-pack-request"},
        {"Accept", "application/x-git-upload-pack-result"}
    });

    session.SetBody(cpr::Body{postReq});
    cpr::Response bodyResp = session.Post();

    if (bodyResp.status_code != 200) {
        std::cerr << "Error during POST request.\n";
        std::cerr << "Status code: " << bodyResp.status_code << "\n";
        std::cerr << "Error message: " << bodyResp.error.message << "\n";
        std::cerr << "Server response: " << bodyResp.text << "\n";
        return EXIT_FAILURE;
    }

    //4. RECEIVE AND DEMULTIPLEX THE RESPONSE
    const std::string& raw_response = bodyResp.text;

    auto packfile_opt = readPackFile(raw_response);

    if (!packfile_opt){
        std::cerr << "Couldn't read the packfile \n";
        return EXIT_FAILURE;
    }
    std::cout << "SUCCESS READING PACKFILE\n";


    // 5. PARSE THE PACKFILE DATA
    std::cout << "\nStarting packfile analysis...\n";

    // Crée une instance de l'analyseur avec les données du packfile.
    std::vector<std::byte> packfile = *packfile_opt;
    PackfileParser parser(packfile);
    
    // Lance l'analyse. Cette méthode peut lancer une exception si le packfile est corrompu.
    auto objects_opt = parser.parseAndResolve();

    if (!objects_opt){
        std::cerr << "Couldn't parse the packfile \n";
        return EXIT_FAILURE;
    }

    std::vector<PackObjectInfo> objects = *objects_opt;

    std::cout << "Analysis complete. Found " << objects.size() << " objects.\n";
    std::cout << "--- Simulating 'git verify-pack -v' output ---\n";

    // Affiche les informations de chaque objet, dans le format souhaité.
    for (const auto& obj : objects) {
        std::cout << obj.sha1 << " "
                    << typeToStringMap.at(obj.type) << " "
                    << obj.uncompressed_size << " "
                    << obj.size_in_packfile << " "
                    << obj.offset_in_packfile;
        if(!obj.delta_ref.empty()){
            // Pour les deltas, on affiche la profondeur (simplifiée à 1) et la référence de base.
            std::cout << " 1 " << obj.delta_ref;
        }
        std::cout << std::endl;
    }
     // NOUVELLE ÉTAPE 6 : ÉCRIRE LES OBJETS DANS LA BASE DE DONNÉES LOCALE
    std::cout << "\nÉtape 6 : Écriture des objets dans .git/objects...\n";
    
    // On récupère les données brutes des objets résolus depuis le parser
    const auto& resolved_data_map = parser.getResolvedObjectsData();
    int written_count = 0;
    
    for (const auto& obj_info : objects) {
        // On reconstruit le contenu complet de l'objet (en-tête + données)
        // C'est ce contenu qui est hashé et compressé par Git.
        
        // a. Récupérer les données brutes de l'objet via son SHA
        const auto& data = resolved_data_map.at(obj_info.sha1);
        
        // b. Construire l'en-tête Git ("<type> <taille>\0")
        std::string header_str = typeToStringMap.at(obj_info.type) + " " + std::to_string(data.size()) + '\0';

        // c. Concaténer l'en-tête et les données
        std::vector<std::byte> full_object_content;
        full_object_content.reserve(header_str.size() + data.size());
        std::transform(header_str.begin(), header_str.end(), std::back_inserter(full_object_content), 
                        [](char c){ return static_cast<std::byte>(c); });
        full_object_content.insert(full_object_content.end(), data.begin(), data.end());

        // d. Appeler ta fonction pour écrire l'objet sur le disque
        if (writeGitObject(full_object_content)) {
            written_count++;
        } else {
            std::cerr << "Erreur critique : impossible d'écrire l'objet " << obj_info.sha1 << " sur le disque.\n";
            // On pourrait décider de s'arrêter ici ou de continuer
            return EXIT_FAILURE;
        }
    }
    
    std::cout << written_count << " objets écrits avec succès dans le répertoire .git/objects.\n";

    // ÉTAPE 7 : METTRE À JOUR HEAD (et autres refs)
    // C'est la prochaine étape logique : il faut créer .git/HEAD pour qu'il pointe
    // vers la branche principale (ex: "ref: refs/heads/main")
    // et créer .git/refs/heads/main contenant le SHA du commit.
    std::cout << "\nÉtape 7 : Mise à jour de HEAD...\n";
    // ... (Code à implémenter pour la gestion des références)
    // ...

    std::cout << "\nClone terminé avec succès.\n";
    return EXIT_SUCCESS;
}




// =================================================================
// File: src/commands/commit_tree.cpp
// =================================================================

#include "../include/ls_tree.h"
#include "../include/object_utils.h"
#include "../include/constants.h"
#include "../include/sha1_utils.h"
#include "../include/time_utils.h"

#include <iostream>
#include <vector>
#include <algorithm>

int handleCommitTree(int argc, char* argv[]){
    bool firstCommit = false;
    std::string treeSha;
    std::string commitMessage;
    std::string previousCommitSha;

    if (argc == 5 && std::string(argv[3]) == "-m") {
        firstCommit = true;
        treeSha = argv[2];
        commitMessage = argv[4];
    } else if (argc == 7 && std::string(argv[3]) == "-p" && std::string(argv[5]) == "-m") {
        treeSha = argv[2];
        previousCommitSha = argv[4];
        commitMessage = argv[6];

    } else {
        std::cerr << "Usage: mygit commit-tree <tree_sha> [-p <commit_sha>] -m <message>\n";
        return EXIT_FAILURE;
    }

    std::ostringstream commitDataStream;
    
    commitDataStream << "tree " << treeSha << "\n";

    if (!firstCommit) {
        commitDataStream << "parent " << previousCommitSha << "\n";
    }

    const std::string timestamp = getGitTimestamp();
    
    // For now hardcoded 
    commitDataStream << "author " << constants::AUTHOR_NAME << " <" << constants::AUTHOR_EMAIL << "> " << timestamp << "\n";
    commitDataStream << "committer " << constants::AUTHOR_NAME << " <" << constants::AUTHOR_EMAIL << "> " << timestamp << "\n";
    
    commitDataStream << "\n" << commitMessage << "\n";

    std::string commitContentStr = commitDataStream.str();
    
    std::string header = "commit " + std::to_string(commitContentStr.size()) + '\0';
    std::string fullCommitObjectStr = header + commitContentStr;

    std::span<const std::byte> fullCommitObjectBytes = std::as_bytes(std::span{fullCommitObjectStr});

    auto sha1BytesOpt = writeGitObject(fullCommitObjectBytes);
    if (sha1BytesOpt) {
        std::cout << bytesToHex(*sha1BytesOpt) << "\n";
    } else {
        std::cerr << "Failed to write commit object.\n";
        return EXIT_FAILURE;
    }

    return EXIT_SUCCESS;
}

// =================================================================
// File: src/commands/hash_object.cpp
// =================================================================

#include "../include/hash_object.h"
#include "../include/constants.h"
#include "../include/object_utils.h"
#include "../include/sha1_utils.h"

#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <optional>
#include <algorithm>


// Its job is to prepare a blob and write it, returning its bytes SHA.
std::optional<std::vector<std::byte>> createBlobAndGetRawSha(const std::filesystem::path& filePath) {
    std::ifstream inFile(filePath, std::ios::binary);
    if (!inFile) {
        return std::nullopt; // Caller will handle the error message
    }

     // 1. Read the raw characters from the file into a temporary vector of char.
    const std::vector<char> fileContent(
        (std::istreambuf_iterator<char>(inFile)),
        std::istreambuf_iterator<char>()
    );

    // 2. Prepare the Git object header.
    std::string header = "blob " + std::to_string(fileContent.size()) + '\0';
    
    // 3. Construct the final blob content vector of bytes.
    std::vector<std::byte> blobContent;
    blobContent.reserve(header.length() + fileContent.size());

    // Insert header bytes directly
    blobContent.insert(blobContent.end(), 
                    reinterpret_cast<const std::byte*>(header.data()), 
                    reinterpret_cast<const std::byte*>(header.data()) + header.length());

    // Insert file content bytes directly
    blobContent.insert(blobContent.end(), 
                    reinterpret_cast<const std::byte*>(fileContent.data()), 
                    reinterpret_cast<const std::byte*>(fileContent.data()) + fileContent.size());

    // 4. Write the final object and return its SHA.
    return writeGitObject(blobContent);
}

int handleHashObject(int argc, char* argv[]) {
    if (argc != 4 || std::string(argv[2]) != "-w") {
        std::cerr << "Usage: mygit hash-object -w <file-path>\n";
        return EXIT_FAILURE;
    }

    const std::filesystem::path filePath = argv[3];
    auto sha1BytesOpt = createBlobAndGetRawSha(filePath);

    if (sha1BytesOpt) {
        std::cout << bytesToHex(*sha1BytesOpt) << "\n"; // Convert to hex only for display
        return EXIT_SUCCESS;
    } else {
        std::cerr << "Error: cannot create blob object from: " << filePath << '\n';
        return EXIT_FAILURE;
    }
}

// =================================================================
// File: src/commands/init.cpp
// =================================================================

#include "../include/init.h"
#include "../include/constants.h"

#include <iostream>
#include <filesystem>
#include <fstream>

int handleInit() {
    try {
        std::filesystem::create_directory(constants::GIT_DIR);
        std::filesystem::create_directory(constants::OBJECTS_DIR);
        std::filesystem::create_directory(constants::GIT_DIR / constants::REFS_DIR_NAME);

        std::ofstream headFile(constants::GIT_DIR / constants::HEAD_FILE_NAME);
        if (headFile.is_open()) {
            headFile << "ref: refs/heads/main\n";
        } else {
            std::cerr << "Failed to create " << constants::HEAD_FILE_NAME << " file.\n";
            return EXIT_FAILURE;
        }

        std::cout << "Initialized empty Git repository in " 
                  << std::filesystem::absolute(constants::GIT_DIR).string() << "/\n";

    } catch (const std::filesystem::filesystem_error& e) {
        std::cerr << "Error: " << e.what() << '\n';
        return EXIT_FAILURE;
    }
    return EXIT_SUCCESS;
}

// =================================================================
// File: src/commands/ls_tree.cpp
// =================================================================

#include "../include/ls_tree.h"
#include "../include/object_utils.h"
#include "../include/tree_parser.h"
#include "../include/sha1_utils.h"
#include "../include/constants.h"

#include <iostream>
#include <string>
#include <vector>
#include <optional>
#include <algorithm> 
#include <span>


int handleLsTree(int argc, char* argv[]) {
    bool nameOnly = false;
    std::string treeSha;

    if (argc == 4 && std::string(argv[2]) == "--name-only") {
        nameOnly = true;
        treeSha = argv[3];
    } else if (argc == 3) {
        treeSha = argv[2];
    } else {
        std::cerr << "Usage: mygit ls-tree [--name-only] <tree-sha>\n";
        return EXIT_FAILURE;
    }

    auto decompressedDataOpt = readGitObject(treeSha);
    if (!decompressedDataOpt) {
        std::cerr << "Fatal: Not a valid object name " << treeSha << '\n';
        return EXIT_FAILURE;
    }

    // *** FIX #1: Create a span and work consistently with it ***
    const auto& decompressedDataVec = *decompressedDataOpt;
    std::span<const std::byte> dataSpan(decompressedDataVec);

    auto nullPosIt = findNullSeparator(dataSpan);
    if (nullPosIt == dataSpan.end()) { // Compare span::iterator to span::iterator
        std::cerr << "Invalid tree object: missing header\n";
        return EXIT_FAILURE;
    }

    // The tree content is everything *after* the null byte separator.
    // Use the span's subspan feature for a clean, safe way to get the content view.
    auto treeContent = dataSpan.subspan(std::distance(dataSpan.begin(), nullPosIt) + 1);

    auto entriesOpt = parseTreeObject(treeContent);
    if (!entriesOpt) {
        std::cerr << "Failed to parse tree object\n";
        return EXIT_FAILURE;
    }

    for (const auto& entry : *entriesOpt) {
        if (nameOnly) {
            std::cout << entry.filename << "\n";
        } else {
            // Now the compiler knows what constants::MODE_TREE is
            const std::string type = (entry.mode == constants::MODE_TREE) ? "tree" : "blob";
            std::cout << entry.mode << " " << type << " " << bytesToHex(entry.sha1Bytes) << "\t" << entry.filename << "\n";
        }
    }

    return EXIT_SUCCESS;
}

// =================================================================
// File: src/commands/write_tree.cpp
// =================================================================

#include "../include/write_tree.h"
#include "../include/hash_object.h"
#include "../include/object_utils.h"
#include "../include/constants.h"
#include "../include/sha1_utils.h"

#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
#include <iterator>
#include <optional>

std::optional<std::vector<std::byte>> writeTreeFromDirectory(const std::filesystem::path& dirPath) {
    std::vector<TreeEntry> entries;

    std::vector<std::filesystem::directory_entry> files;
    for (const auto& entry : std::filesystem::directory_iterator(dirPath)) {
        files.push_back(entry);
    }
    std::sort(files.begin(), files.end(), [](const auto& a, const auto& b) {
        return a.path().filename() < b.path().filename();
    });

    for (const auto& file : files) {
        auto filename = file.path().filename().string();
        if (filename == constants::GIT_DIR_NAME) {
            continue;
        }

        TreeEntry entry;
        entry.filename = filename;

        if (file.is_directory()) {
            entry.mode = constants::MODE_TREE;
            auto sha1BytesOpt = writeTreeFromDirectory(file.path());
            if (!sha1BytesOpt) return std::nullopt;
            entry.sha1Bytes = *sha1BytesOpt;
        } else if (file.is_regular_file()) {
            entry.mode = constants::MODE_BLOB;
            auto sha1BytesOpt = createBlobAndGetRawSha(file.path()); 
            if (!sha1BytesOpt) return std::nullopt;
            entry.sha1Bytes = *sha1BytesOpt;
        } else {
            continue; // Skip symlinks, etc. for now
        }
        entries.push_back(entry);
    }

    // Construct the tree object content from the entries "mode filename\0rawSha1Bytes"
    std::vector<std::byte> treeContent;
    for (const auto& entry : entries) {
        std::string entryStr = entry.mode + " " + entry.filename + '\0';
        std::transform(entryStr.begin(), entryStr.end(), std::back_inserter(treeContent), 
                       [](char c){ return std::byte(c); });
        treeContent.insert(treeContent.end(), entry.sha1Bytes.begin(), entry.sha1Bytes.end());
    }

    // Construct the full object with header 
    std::string header = "tree " + std::to_string(treeContent.size()) + '\0';
    std::vector<std::byte> fullTreeObject;
    std::transform(header.begin(), header.end(), std::back_inserter(fullTreeObject),
                   [](char c){ return std::byte(c); });
    fullTreeObject.insert(fullTreeObject.end(), treeContent.begin(), treeContent.end());
    
    auto sha1BytesOpt = writeGitObject(fullTreeObject);
    
    return sha1BytesOpt;
}

int handleWriteTree(int argc, char* argv[]) {
    auto sha1BytesOpt = writeTreeFromDirectory(".");
    if (sha1BytesOpt) {
        std::cout << bytesToHex(*sha1BytesOpt) << "\n"; // The * dereferences sha1BytesOpt, which means it accesses the value stored within the optional object.
        return EXIT_SUCCESS;
    }
    std::cerr << "Failed to write tree object.\n";
    return EXIT_FAILURE;
}

// =================================================================
// File: src/include/cat_file.h
// =================================================================

#pragma once
int handleCatFile(int argc, char* argv[]);

// =================================================================
// File: src/include/clone.h
// =================================================================

#pragma once

int handleClone(int argc, char* argv[]);

// =================================================================
// File: src/include/commit_tree.h
// =================================================================

#pragma once

int handleCommitTree(int argc, char* argv[]);

// =================================================================
// File: src/include/constants.h
// =================================================================

#pragma once

#include <string_view>
#include <filesystem>

// This file centralizes constants to avoid "magic strings" scattered in the code.
// Using string_view is efficient as it avoids string constructions.

namespace constants {
    constexpr std::string_view GIT_DIR_NAME = ".git";
    constexpr std::string_view OBJECTS_DIR_NAME = "objects";
    constexpr std::string_view REFS_DIR_NAME = "refs";
    constexpr std::string_view HEAD_FILE_NAME = "HEAD";
    
    constexpr std::string_view MODE_BLOB = "100644";
    constexpr std::string_view MODE_TREE = "040000";

    constexpr std::string_view AUTHOR_NAME = "Mathis-L";
    constexpr std::string_view AUTHOR_EMAIL = "mathislafon@gmail.com";

    const std::filesystem::path GIT_DIR = ".git";
    const std::filesystem::path OBJECTS_DIR = GIT_DIR / "objects";
}

// =================================================================
// File: src/include/hash_object.h
// =================================================================

#pragma once
#include <string>
#include <vector>
#include <optional>
#include <filesystem>

// Handles `git hash-object -w <file>`
int handleHashObject(int argc, char* argv[]);

std::optional<std::vector<std::byte>> createBlobAndGetRawSha(const std::filesystem::path& filePath);


// =================================================================
// File: src/include/init.h
// =================================================================

#pragma once
int handleInit();

// =================================================================
// File: src/include/ls_tree.h
// =================================================================

#pragma once

int handleLsTree(int argc, char* argv[]);

// =================================================================
// File: src/include/object_utils.h
// =================================================================

#pragma once

#include <string>
#include <vector>
#include <optional>
#include <cstddef>
#include <span>

// Represents a single entry (file or directory) within a Git tree object.
struct TreeEntry {
    std::string mode;
    std::string filename;
    std::vector<std::byte> sha1Bytes; // 20-byte raw SHA1 hash
};


// Reads and decompresses a git object from the .git/objects directory
std::optional<std::vector<std::byte>> readGitObject(const std::string& sha1Hex);

// Hashes, compresses, and writes content to the .git/objects directory.
// Returns the hex SHA-1 hash of the object on success.
std::optional<std::vector<std::byte>> writeGitObject(std::span<const std::byte> content);

// Helper to find the first null separator in a byte span
std::span<const std::byte>::iterator findNullSeparator(std::span<const std::byte> data);

// =================================================================
// File: src/include/packfile_utils.h
// =================================================================

#pragma once

#include <string>
#include <vector>
#include <cstdint>
#include <optional>
#include <map>

enum class GitObjectType {
    NONE = 0,
    COMMIT = 1,
    TREE = 2,
    BLOB = 3,
    TAG = 4,
    OFS_DELTA = 6,
    REF_DELTA = 7
};

// Fonction pour convertir un type d'objet en chaîne de caractères pour l'affichage.
static const std::map<GitObjectType, std::string> typeToStringMap = {
    {GitObjectType::COMMIT, "commit"},
    {GitObjectType::TREE, "tree"},
    {GitObjectType::BLOB, "blob"},
    {GitObjectType::TAG, "tag"},
    {GitObjectType::OFS_DELTA, "ofs-delta"},
    {GitObjectType::REF_DELTA, "ref-delta"}
};

// Structure pour stocker les informations d'un seul objet parsé.
struct PackObjectInfo {
    std::string sha1;
    GitObjectType type;
    size_t uncompressed_size;
    size_t size_in_packfile;
    size_t offset_in_packfile;
    // Pour les deltas, nous stockons la référence au "base object"
    std::string delta_ref; 
};

struct PendingDeltaObject {
    PackObjectInfo info;
    std::vector<std::byte> delta_data;
};


class PackfileParser {
public:
    // Le constructeur prend le vecteur d'octets du packfile.
    PackfileParser(const std::vector<std::byte>& packfile_data);

    // La méthode principale qui lance l'analyse.
    std::optional<std::vector<PackObjectInfo>> parseAndResolve();

    // Permet de récupérer les données brutes (sans en-tête) des objets résolus
    // La clé est le SHA-1 de l'objet.
    const std::map<std::string, std::vector<std::byte>>& getResolvedObjectsData() const;

private:
    const std::vector<std::byte>& m_packfile;
    size_t m_cursor;

    std::map<std::string, std::vector<std::byte>> m_object_data_cache; // sha1 -> raw_data
    std::map<std::string, GitObjectType> m_object_type_cache;          // sha1 -> type
    std::map<size_t, std::string> m_offset_to_sha_map;                 // offset -> sha1

    // Lit un entier 32-bit Big Endian et avance le curseur.
    uint32_t read_big_endian_32();
    
    // Vérifie l'en-tête 'PACK' et la version.
    bool verify_header();

    // La fonction la plus importante: parse un seul objet.
    PackObjectInfo parse_object(); 

    // Lit un entier à taille variable (utilisé pour les tailles d'objet et les en-têtes de delta)
    uint64_t read_variable_length_integer(size_t& cursor, const std::vector<std::byte>& data);
    std::vector<std::byte> apply_delta(const std::vector<std::byte>& base, const std::vector<std::byte>& delta_instructions);
    
    // Décompresse les données à partir du curseur actuel en utilisant zlib.
    std::pair<std::vector<std::byte>, size_t> decompress_data(size_t uncompressed_size);
};


// =================================================================
// File: src/include/pkt_line_utils.h
// =================================================================

#pragma once
#include <istream>
#include <vector>
#include <string>
#include <optional>

class PktLineReader {
private:
    std::istream& m_stream;
    bool m_is_finished;

public:
    PktLineReader(std::istream& stream);

    std::optional<std::vector<std::byte>> readNextPacket();
};

std::optional<std::string> findMainBranchSha1(const std::string& str);

std::string createPktLine(const std::string& line);

std::optional<std::vector<std::byte>>  readPackFile(const std::string& str);

// =================================================================
// File: src/include/sha1_utils.h
// =================================================================

#pragma once
#include <string>
#include <vector>
#include <span>

std::vector<std::byte> calculateSha1(std::span<const std::byte> data);

std::string bytesToHex(std::span<const std::byte> bytes);

std::string calculateSha1Hex(std::span<const std::byte> data);

std::vector<std::byte> hexToBytes(const std::string& hex);

// =================================================================
// File: src/include/time_utils.h
// =================================================================

#pragma once 

#include <string>

std::string getGitTimestamp();

// =================================================================
// File: src/include/tree_parser.h
// =================================================================

#pragma once
#include <string>
#include <vector>
#include "object_utils.h"

// Parses a Git tree object into TreeEntry structs
std::optional<std::vector<TreeEntry>> parseTreeObject(std::span<const std::byte> treeContent);

// =================================================================
// File: src/include/write_tree.h
// =================================================================

#pragma once
#include <vector>
#include <filesystem>
#include <optional>

int handleWriteTree(int argc, char* argv[]);
std::optional<std::vector<std::byte>> writeTreeFromDirectory(const std::filesystem::path& dirPath);

// =================================================================
// File: src/include/zlib_utils.h
// =================================================================

#pragma once
#include <vector>
#include <string>
#include <span>

bool decompressZlib(std::span<const std::byte> input, std::vector<std::byte>& output);
bool compressZlib(std::span<const std::byte> input, std::vector<std::byte>& output);

// =================================================================
// File: src/main.cpp
// =================================================================

#include <iostream>
#include <string>
#include <zlib.h>
#include <vector>
#include <iterator>
#include <algorithm>
#include <openssl/sha.h>

#include "include/init.h"
#include "include/cat_file.h"
#include "include/hash_object.h"
#include "include/ls_tree.h"
#include "include/write_tree.h"
#include "include/commit_tree.h"
#include "include/clone.h"


int main(int argc, char* argv[]) {
    // Flush after every std::cout / std::cerr
    std::cout << std::unitbuf;
    std::cerr << std::unitbuf;

    // You can use print statements as follows for debugging, they'll be visible when running tests.
    std::cerr << "Logs from your program will appear here!\n";

    // Uncomment this block to pass the first stage
    if (argc < 2) {
        std::cerr << "No command provided.\n";
        return EXIT_FAILURE;
    }

    const std::string command = argv[1];
    if (command == "init") {
        return handleInit();
    } else if (command == "hash-object") {
        return handleHashObject(argc, argv);
    } else if (command == "cat-file") {
        return handleCatFile(argc, argv);
    } else if (command == "ls-tree") {
        return handleLsTree(argc, argv);
    } else if (command == "write-tree"){
        return handleWriteTree(argc, argv);
    } else if (command == "commit-tree"){
        return handleCommitTree(argc, argv);
    } else if (command == "clone"){
        return handleClone(argc, argv);
    }

    std::cerr << "Unknown command: " << command << "\n";
    return EXIT_FAILURE;
}



// =================================================================
// File: src/utils/object_utils.cpp
// =================================================================

#include "../include/object_utils.h"
#include "../include/constants.h"
#include "../include/sha1_utils.h"
#include "../include/zlib_utils.h"

#include <fstream>
#include <filesystem>
#include <iostream>
#include <algorithm>

std::optional<std::vector<std::byte>> readGitObject(const std::string& sha1Hex) {
    if (sha1Hex.length() != 40) {
        return std::nullopt;
    }
    const auto objectPath = constants::OBJECTS_DIR / sha1Hex.substr(0, 2) / sha1Hex.substr(2);

    if (!std::filesystem::exists(objectPath)) {
        return std::nullopt;
    }

    std::ifstream objectFile(objectPath, std::ios::binary);
    if (!objectFile) {
        return std::nullopt;
    }

    // Read entire file into a buffer
    objectFile.seekg(0, std::ios::end);
    std::streamsize size = objectFile.tellg();
    objectFile.seekg(0, std::ios::beg);

    std::vector<std::byte> compressedData(size);
    if (!objectFile.read(reinterpret_cast<char*>(compressedData.data()), size)) {
        return std::nullopt;
    }

    std::vector<std::byte> decompressedData;
    if (!decompressZlib(compressedData, decompressedData)) {
        return std::nullopt;
    }

    return decompressedData;
}

std::optional<std::vector<std::byte>> writeGitObject(std::span<const std::byte> content) {
    // 1. Compute SHA-1
    std::vector<std::byte> sha1Bytes = calculateSha1(content);

    // 2. Convert the raw hash to hex *only* for creating the file path.
    std::string sha1Hex = bytesToHex(sha1Bytes);

    // 3. Prepare object path
    const auto dir = constants::OBJECTS_DIR / sha1Hex.substr(0, 2);
    const auto filePath = dir / sha1Hex.substr(2);

    // Don't rewrite if it already exists
    if (std::filesystem::exists(filePath)) {
        return sha1Bytes;
    }

    // 3. Compress object data
    std::vector<std::byte> compressedData;
    if (!compressZlib(content, compressedData)) {
        std::cerr << "Compression failed\n";
        return std::nullopt;
    }
    
    // 4. Write compressed object to disk
    try {
        std::filesystem::create_directories(dir);
        std::ofstream outFile(filePath, std::ios::binary | std::ios::trunc);
        if (!outFile) {
             return std::nullopt;
        }
        outFile.write(reinterpret_cast<const char*>(compressedData.data()), compressedData.size());
    } catch (const std::filesystem::filesystem_error& e) {
        std::cerr << "Filesystem error: " << e.what() << '\n';
        return std::nullopt;
    }

    return sha1Bytes;
}

std::span<const std::byte>::iterator findNullSeparator(std::span<const std::byte> data) {
    return std::find(data.begin(), data.end(), std::byte{0});
}

// =================================================================
// File: src/utils/packfile_utils.cpp
// =================================================================

#include "../include/packfile_utils.h"
#include "../include/sha1_utils.h"
#include <zlib.h>

#include <iostream>
#include <vector>
#include <string>
#include <fstream>
#include <cstddef>
#include <iomanip>
#include <optional>
#include <algorithm>
#include <span>

PackfileParser::PackfileParser(const std::vector<std::byte>& packfile_data): m_packfile(packfile_data), m_cursor(0) {}

const std::map<std::string, std::vector<std::byte>>& PackfileParser::getResolvedObjectsData() const {
    return m_object_data_cache;
}

std::optional<std::vector<PackObjectInfo>> PackfileParser::parseAndResolve() {
    if (m_packfile.size() < 12 || !verify_header()) {
        return std::nullopt;
    }
    
    uint32_t num_objects = read_big_endian_32();
    std::cout << "Nombre d'objets déclaré dans le packfile : " << num_objects << std::endl;

    m_object_data_cache.clear();
    m_object_type_cache.clear();
    m_offset_to_sha_map.clear();

    std::vector<PackObjectInfo> final_objects;
    std::vector<PendingDeltaObject> pending_deltas;

    // ======================================================
    // PASSE 1: PARSE TOUS LES OBJETS, MET LES DELTAS EN ATTENTE
    // ======================================================
    for (uint32_t i = 0; i < num_objects; ++i) {
        PackObjectInfo info;
        info.offset_in_packfile = m_cursor;

        // 1. Décode l'en-tête de l'objet (type et taille)
        size_t header_start_cursor = m_cursor;
        
        std::byte first_byte = m_packfile[m_cursor++];
        info.type = static_cast<GitObjectType>((static_cast<uint8_t>(first_byte) >> 4) & 0x7);
        
        uint64_t size = static_cast<uint8_t>(first_byte) & 0x0F;
        int shift = 4;
        while ((static_cast<uint8_t>(first_byte) & 0x80) != 0) {
            first_byte = m_packfile[m_cursor++];
            size |= (static_cast<uint64_t>(static_cast<uint8_t>(first_byte) & 0x7F)) << shift;
            shift += 7;
        }
        info.uncompressed_size = size;
        
        // 2. Gère les deltas pour identifier leur base
        if (info.type == GitObjectType::REF_DELTA) {
            std::span<const std::byte> sha1_ref_span(&m_packfile[m_cursor], 20);
            info.delta_ref = bytesToHex(sha1_ref_span);
            m_cursor += 20;
        } else if (info.type == GitObjectType::OFS_DELTA) {
            uint64_t offset_delta = read_variable_length_integer(m_cursor, m_packfile);
            size_t base_offset = info.offset_in_packfile - offset_delta;
            // On stocke l'offset de base sous forme de string pour réutiliser le champ delta_ref.
            info.delta_ref = std::to_string(base_offset);
        }

        // 3. Décompresse les données (objet complet ou instructions delta)
        size_t data_start_cursor = m_cursor;
        auto [data, bytes_consumed] = decompress_data(info.uncompressed_size);
        m_cursor = data_start_cursor + bytes_consumed;
        info.size_in_packfile = m_cursor - info.offset_in_packfile;

        // 4. Stocke l'objet ou le met en attente
        if (info.type != GitObjectType::OFS_DELTA && info.type != GitObjectType::REF_DELTA) {
            // C'est un objet de base, on calcule son SHA et on le met en cache
            std::string header = typeToStringMap.at(info.type) + " " + std::to_string(data.size()) + '\0';
            std::vector<std::byte> full_object_data;
            full_object_data.reserve(header.size() + data.size());
            std::transform(header.begin(), header.end(), std::back_inserter(full_object_data), 
                            [](char c){ return static_cast<std::byte>(c); });
            full_object_data.insert(full_object_data.end(), data.begin(), data.end());
            
            info.sha1 = calculateSha1Hex(full_object_data);
            
            // Mise en cache
            m_object_data_cache[info.sha1] = data;
            m_object_type_cache[info.sha1] = info.type;
            m_offset_to_sha_map[info.offset_in_packfile] = info.sha1;

            final_objects.push_back(info);
        } else {
            // C'est un delta, on le met en attente
            pending_deltas.push_back({info, data});
        }
    }

    // ======================================================
    // PASSE 2: RÉSOUT LES DELTAS (EN PLUSIEURS PASSES SI NÉCESSAIRE)
    // ======================================================
    size_t passes = 0;
    while (!pending_deltas.empty()) {
        if (passes++ > num_objects) { // Sécurité pour éviter les boucles infinies
            std::cerr << "Error: Could not resolve all deltas, possible missing base or circular dependency." << std::endl;
            break;
        }
        
        size_t resolved_count_this_pass = 0;
        std::vector<PendingDeltaObject> next_pending_deltas;

        for (const auto& pending : pending_deltas) {
            std::string base_sha1;
            
            // Trouve le SHA-1 de l'objet de base
            if (pending.info.type == GitObjectType::OFS_DELTA) {
                size_t base_offset = std::stoull(pending.info.delta_ref);
                auto it = m_offset_to_sha_map.find(base_offset);
                if (it == m_offset_to_sha_map.end()) {
                    next_pending_deltas.push_back(pending); // Base pas encore disponible, on réessaie plus tard
                    continue;
                }
                base_sha1 = it->second;
            } else { // REF_DELTA
                base_sha1 = pending.info.delta_ref;
            }

            // Récupère les données et le type de la base depuis le cache
            auto base_data_it = m_object_data_cache.find(base_sha1);
            auto base_type_it = m_object_type_cache.find(base_sha1);

            if (base_data_it == m_object_data_cache.end() || base_type_it == m_object_type_cache.end()) {
                next_pending_deltas.push_back(pending); // Base pas encore disponible
                continue;
            }
            
            // On a trouvé la base, on peut résoudre le delta
            const auto& base_data = base_data_it->second;
            const auto& base_type = base_type_it->second;
            
            std::vector<std::byte> resolved_data = apply_delta(base_data, pending.delta_data);

            PackObjectInfo resolved_info = pending.info;
            resolved_info.type = base_type; // Le type de l'objet résolu est celui de sa base !

            // Calcule le SHA-1 de l'objet nouvellement reconstruit
            std::string header = typeToStringMap.at(resolved_info.type) + " " + std::to_string(resolved_data.size()) + '\0';
            std::vector<std::byte> full_object_data;
            std::transform(header.begin(), header.end(), std::back_inserter(full_object_data), 
                            [](char c){ return static_cast<std::byte>(c); });
            full_object_data.insert(full_object_data.end(), resolved_data.begin(), resolved_data.end());

            resolved_info.sha1 = calculateSha1Hex(full_object_data);
            
            // Ajoute l'objet résolu aux caches pour qu'il puisse servir de base à son tour
            m_object_data_cache[resolved_info.sha1] = resolved_data;
            m_object_type_cache[resolved_info.sha1] = resolved_info.type;
            m_offset_to_sha_map[resolved_info.offset_in_packfile] = resolved_info.sha1;
            
            final_objects.push_back(resolved_info);
            resolved_count_this_pass++;
        }

        if (resolved_count_this_pass == 0 && !next_pending_deltas.empty()) {
             std::cerr << "Error: Made no progress in resolving deltas on this pass." << std::endl;
             break;
        }

        pending_deltas = next_pending_deltas;
    }
    
    // Trie les objets par offset pour correspondre à l'ordre original du packfile
    std::sort(final_objects.begin(), final_objects.end(), [](const auto& a, const auto& b){
        return a.offset_in_packfile < b.offset_in_packfile;
    });

    return final_objects;
}


uint64_t PackfileParser::read_variable_length_integer(size_t& cursor, const std::vector<std::byte>& data) {
    uint64_t value = 0;
    int shift = 0;
    std::byte current_byte;
    do {
        if (cursor >= data.size()) {
            throw std::runtime_error("Unexpected end of data while reading variable-length integer.");
        }
        current_byte = data[cursor++];
        uint64_t chunk = static_cast<uint64_t>(static_cast<uint8_t>(current_byte) & 0x7F);
        value |= (chunk << shift);
        shift += 7;
    } while ((static_cast<uint8_t>(current_byte) & 0x80) != 0);
    return value;
}


uint32_t PackfileParser::read_big_endian_32() {
    uint32_t value = 0;
    value |= static_cast<uint32_t>(m_packfile[m_cursor++]) << 24;
    value |= static_cast<uint32_t>(m_packfile[m_cursor++]) << 16;
    value |= static_cast<uint32_t>(m_packfile[m_cursor++]) << 8;
    value |= static_cast<uint32_t>(m_packfile[m_cursor++]);
    return value;
}

bool PackfileParser::verify_header() {
    // "PACK"
    if (m_packfile[0] != std::byte{'P'} || m_packfile[1] != std::byte{'A'} ||
        m_packfile[2] != std::byte{'C'} || m_packfile[3] != std::byte{'K'}) {
        return false;
    }
    std::cout << "PACK valid" << std::endl;

    m_cursor += 4;

    uint32_t version = read_big_endian_32();
    if (version != 2) {
       return false;
    }
    std::cout << "header correct" << std::endl;
    std::cout << "m_cursor = " << m_cursor << std::endl;
    return true;
}

std::pair<std::vector<std::byte>, size_t> PackfileParser::decompress_data(size_t uncompressed_size) {
    // Si uncompressed_size est 0, on sait que le résultat est un vecteur vide.
    // La question est de savoir combien d'octets de données d'entrée sont consommés.
    // On doit quand même initialiser zlib pour qu'il nous le dise.
    if (uncompressed_size == 0) {
        // Créeons un buffer de sortie factice de 1 octet, juste pour que le pointeur ne soit pas nul.
        // zlib retournera une erreur si on essaie d'y écrire, mais ce n'est pas grave.
        std::byte dummy_buffer[1];
        z_stream strm = {};
        strm.avail_in = m_packfile.size() - m_cursor;
        strm.next_in = reinterpret_cast<Bytef*>(const_cast<std::byte*>(&m_packfile[m_cursor]));
        strm.avail_out = 0; // On lui dit bien qu'il n'y a pas de place.
        strm.next_out = reinterpret_cast<Bytef*>(dummy_buffer); // Mais le pointeur n'est pas Z_NULL.

        if (inflateInit(&strm) != Z_OK) {
            throw std::runtime_error("zlib inflateInit failed for zero-size object.");
        }

        int ret = inflate(&strm, Z_FINISH);
        
        size_t bytes_consumed = strm.total_in;
        inflateEnd(&strm);

        // Pour un objet vide, on s'attend à ce que Z_STREAM_END soit retourné.
        // Si ce n'est pas le cas, le packfile est probablement corrompu.
        if (ret != Z_STREAM_END) {
             throw std::runtime_error("zlib inflate failed for zero-size object: error code " + std::to_string(ret));
        }
        
        // On retourne bien un vecteur vide, et le nombre d'octets consommés.
        return {{}, bytes_consumed};
    }

    // --- Cas général pour les tailles > 0 ---
    std::vector<std::byte> out_buffer(uncompressed_size);
    z_stream strm = {};
    strm.avail_in = m_packfile.size() - m_cursor;
    strm.next_in = reinterpret_cast<Bytef*>(const_cast<std::byte*>(&m_packfile[m_cursor]));
    strm.avail_out = uncompressed_size;
    strm.next_out = reinterpret_cast<Bytef*>(out_buffer.data());

    if (inflateInit(&strm) != Z_OK) {
        throw std::runtime_error("zlib inflateInit failed.");
    }
    
    int ret = inflate(&strm, Z_FINISH);
    
    size_t bytes_consumed = strm.total_in;
    inflateEnd(&strm);

    if (ret != Z_STREAM_END) {
        throw std::runtime_error("zlib inflate failed: error code " + std::to_string(ret));
    }

    return {out_buffer, bytes_consumed};
}

std::vector<std::byte> PackfileParser::apply_delta(const std::vector<std::byte>& base, const std::vector<std::byte>& delta_instructions) {
    size_t cursor = 0;

    // 1. Lire la taille de l'objet de base (source)
    uint64_t base_size = read_variable_length_integer(cursor, delta_instructions);
    if (base_size != base.size()) {
        throw std::runtime_error("Delta error: Mismatched base size.");
    }

    // 2. Lire la taille de l'objet résultant (cible)
    uint64_t target_size = read_variable_length_integer(cursor, delta_instructions);
    
    std::vector<std::byte> result_data;
    result_data.reserve(target_size);

    // 3. Lire et appliquer les instructions
    while (cursor < delta_instructions.size()) {
        std::byte control_byte = delta_instructions[cursor++];
        
        if ((static_cast<uint8_t>(control_byte) & 0x80) != 0) {
            // Cas B : Instruction de COPIE (MSB = 1)
            uint64_t offset = 0;
            uint64_t size = 0;
            
            // Lire l'offset (4 bits de flag)
            if ((static_cast<uint8_t>(control_byte) & 0x01) != 0) offset |= static_cast<uint64_t>(delta_instructions[cursor++]);
            if ((static_cast<uint8_t>(control_byte) & 0x02) != 0) offset |= (static_cast<uint64_t>(delta_instructions[cursor++]) << 8);
            if ((static_cast<uint8_t>(control_byte) & 0x04) != 0) offset |= (static_cast<uint64_t>(delta_instructions[cursor++]) << 16);
            if ((static_cast<uint8_t>(control_byte) & 0x08) != 0) offset |= (static_cast<uint64_t>(delta_instructions[cursor++]) << 24);

            // Lire la taille (3 bits de flag)
            if ((static_cast<uint8_t>(control_byte) & 0x10) != 0) size |= static_cast<uint64_t>(delta_instructions[cursor++]);
            if ((static_cast<uint8_t>(control_byte) & 0x20) != 0) size |= (static_cast<uint64_t>(delta_instructions[cursor++]) << 8);
            if ((static_cast<uint8_t>(control_byte) & 0x40) != 0) size |= (static_cast<uint64_t>(delta_instructions[cursor++]) << 16);
            
            // Cas spécial : une taille de 0 est traitée comme 0x10000
            if (size == 0) {
                size = 0x10000;
            }
            
            if (offset + size > base.size()) {
                 throw std::runtime_error("Delta error: Copy instruction reads out of base object bounds.");
            }
            
            // Copier les données depuis l'objet de base
            result_data.insert(result_data.end(), base.begin() + offset, base.begin() + offset + size);

        } else {
            // Cas A : Instruction d'AJOUT (MSB = 0)
            uint8_t add_size = static_cast<uint8_t>(control_byte) & 0x7F;
            if (add_size == 0) {
                throw std::runtime_error("Delta error: Add instruction with size 0 is invalid.");
            }
            
            if (cursor + add_size > delta_instructions.size()) {
                 throw std::runtime_error("Delta error: Add instruction reads out of delta data bounds.");
            }

            // Ajouter les données littérales depuis le flux delta
            result_data.insert(result_data.end(), delta_instructions.begin() + cursor, delta_instructions.begin() + cursor + add_size);
            cursor += add_size;
        }
    }
    
    if (result_data.size() != target_size) {
        throw std::runtime_error("Delta error: Final reconstructed size does not match target size.");
    }

    return result_data;
}

// =================================================================
// File: src/utils/pkt_line_utils.cpp
// =================================================================

#include "../include/pkt_line_utils.h"

#include <iostream>
#include <vector>
#include <string>
#include <sstream>
#include <optional>
#include <iomanip> 
#include <optional>
#include <span>

PktLineReader::PktLineReader(std::istream& stream) : m_stream(stream), m_is_finished(false){}

std::optional<std::vector<std::byte>> PktLineReader::readNextPacket(){
    if (m_is_finished) return std::nullopt;

    char length_hex[4];
    m_stream.read(length_hex, 4);

// check if we read 4 characters with read()
    if(m_stream.gcount() < 4){
        m_is_finished = true;
        return std::nullopt;
    }

    // convert the size
    unsigned int length = 0;
    try {
        std::string hex_str(length_hex, 4);
        length = std::stoul(hex_str, nullptr, 16);
    } catch (const std::invalid_argument& e) {
        m_is_finished = true;
        return std::nullopt;
    }

    // flush packet or empty packet
    if (length == 0 || length == 4) {
        return std::vector<std::byte>{};
    }
    
    if (length < 4) {
        m_is_finished = true;
        return std::nullopt;
    }

    // Read data
    size_t content_length = length - 4;
    std::vector<std::byte> content(content_length);
    m_stream.read(reinterpret_cast<char*>(content.data()), content_length);

    if (m_stream.gcount() < content_length) {
        m_is_finished = true;
        return std::nullopt;
    }
    
    return content;
}


std::optional<std::string> findMainBranchSha1(const std::string& str){
    std::istringstream data_stream(str);
    PktLineReader pktLineReader(data_stream);

    pktLineReader.readNextPacket(); //skip header

    while (auto packet_opt = pktLineReader.readNextPacket()){
        std::vector<std::byte>& packet_data = *packet_opt;

        std::string packet_line(reinterpret_cast<const char*>(packet_data.data()), packet_data.size());
        std::cout << "packet_line : " << packet_line << "\n";

        if (!packet_line.empty() && packet_line.back() == '\n') {
            packet_line.pop_back();
        }

        size_t space_pos = packet_line.find(' ');
        if (space_pos == std::string::npos) {
            continue;
        }

        std::string_view sha1(packet_line.c_str(), space_pos);
        std::string_view ref_name(packet_line.c_str() + space_pos + 1);

        if (ref_name == "refs/heads/main" || ref_name == "refs/heads/master") {
            return std::string(sha1); 
        }
    }
    return std::nullopt;
}


std::string createPktLine(const std::string& line) {
    if (line.empty()) {
        return "0000"; // special case flush-pkt
    }

    size_t len = line.length() + 4; 
    std::stringstream ss;
    ss << std::setw(4) << std::setfill('0') << std::hex << len << line;
    return ss.str();
}


std::optional<std::vector<std::byte>> readPackFile(const std::string& str){
    std::istringstream data_stream(str);
    PktLineReader pktLineReader(data_stream);

    std::vector<std::byte> packfile;

    while (auto packet_opt = pktLineReader.readNextPacket()){
        std::vector<std::byte>& packet_data = *packet_opt;

        if (packet_data.empty()) {
            continue; 
        }

        std::byte band_id = packet_data[0]; //check first byte 
        auto content_span = std::span(packet_data).subspan(1);

        if (band_id == std::byte{1}) { // \x01 : mean packfile data
            packfile.insert(packfile.end(), content_span.begin(), content_span.end());

        } else if (band_id == std::byte{2}) { // \x02 progress messages
            std::string message(reinterpret_cast<const char*>(content_span.data()), content_span.size());
             std::cerr << "remote: " << message;
        } else if (band_id == std::byte{3}) { // \x03 error 
            std::string error_message(reinterpret_cast<const char*>(content_span.data()), content_span.size());
            std::cerr << "Error from remote: " << error_message;
            return std::nullopt;
        }
        else{
            continue;
        }
    }
    return packfile;
}

// =================================================================
// File: src/utils/sha1_utils.cpp
// =================================================================

#include "../include/sha1_utils.h"
#include <openssl/sha.h>
#include <sstream>
#include <iomanip>
#include <stdexcept>
#include <span>

std::vector<std::byte> calculateSha1(std::span<const std::byte> data) {
    std::vector<std::byte> hash(SHA_DIGEST_LENGTH);
    SHA1(reinterpret_cast<const unsigned char*>(data.data()), data.size(),
         reinterpret_cast<unsigned char*>(hash.data()));
    return hash;
}

std::string bytesToHex(std::span<const std::byte> bytes) {
    std::ostringstream result;
    result << std::hex << std::setfill('0');
    for (const auto& byte : bytes) {
        result << std::setw(2) << static_cast<unsigned int>(byte);
    }
    return result.str();
}

std::string calculateSha1Hex(std::span<const std::byte> data) {
    return bytesToHex(calculateSha1(data));
}

std::vector<std::byte> hexToBytes(const std::string& hex) {
    if (hex.length() % 2 != 0) {
        throw std::invalid_argument("Hex string must have an even number of characters");
    }
    std::vector<std::byte> bytes;
    bytes.reserve(hex.length() / 2);
    for (unsigned int i = 0; i < hex.length(); i += 2) {
        std::string byteString = hex.substr(i, 2);
        bytes.push_back(static_cast<std::byte>(std::stoul(byteString, nullptr, 16)));
    }
    return bytes;
}

// =================================================================
// File: src/utils/time_utils.cpp
// =================================================================

#include <string>
#include <ctime>
#include <iomanip>
#include <sstream>
#include <cmath>
#include "../include/time_utils.h"

std::string getGitTimestamp() {
    // Get now as seconds since epoch
    std::time_t now = std::time(nullptr);

    std::tm local_tm = *std::localtime(&now);
    std::tm utc_tm   = *std::gmtime(&now);

    // Compute offset from UTC in seconds
    int offset_sec = static_cast<int>(std::difftime(std::mktime(&local_tm), std::mktime(&utc_tm)));

    // Extract components
    char sign = (offset_sec >= 0) ? '+' : '-';
    int abs_offset = std::abs(offset_sec);
    int hours = abs_offset / 3600;
    int minutes = (abs_offset % 3600) / 60;

    // Format result
    std::ostringstream oss;
    oss << now << " "
        << sign
        << std::setw(2) << std::setfill('0') << hours
        << std::setw(2) << std::setfill('0') << minutes;

    return oss.str();
}

// =================================================================
// File: src/utils/tree_parser.cpp
// =================================================================

#include "../include/tree_parser.h"
#include <iostream>
#include <algorithm>
#include <span>

std::optional<std::vector<TreeEntry>> parseTreeObject(std::span<const std::byte> treeContent) {
    std::vector<TreeEntry> entries;
    auto current = treeContent.begin();

    while (current != treeContent.end()) {
        TreeEntry entry;

        // Find space after mode
        auto spacePos = std::find(current, treeContent.end(), std::byte{' '});
        if (spacePos == treeContent.end()) return std::nullopt; // Malformed
        entry.mode = std::string(reinterpret_cast<const char*>(&*current), std::distance(current, spacePos));

        // Find null after filename
        auto nullPos = std::find(spacePos + 1, treeContent.end(), std::byte{0});
        if (nullPos == treeContent.end()) return std::nullopt; // Malformed
        entry.filename = std::string(reinterpret_cast<const char*>(&*(spacePos + 1)), std::distance(spacePos + 1, nullPos));

        // SHA1 is the next 20 bytes
        auto shaStart = nullPos + 1;
        if (std::distance(shaStart, treeContent.end()) < 20) return std::nullopt; // Not enough bytes for SHA
        auto shaEnd = shaStart + 20;
        entry.sha1Bytes.assign(shaStart, shaEnd);
        
        entries.push_back(entry);
        current = shaEnd;
    }

    return entries;
}

// =================================================================
// File: src/utils/zlib_utils.cpp
// =================================================================

#include "../include/zlib_utils.h"
#include <zlib.h>
#include <span>


bool decompressZlib(std::span<const std::byte> input, std::vector<std::byte>& output) {
    // Start with a reasonable guess for the output size.
    // Git objects often have good compression, so 3x is a safe starting point.
    size_t output_size = input.size() * 3;
    if (output_size < 1024) output_size = 1024; // Minimum buffer size
    output.resize(output_size);

    while (true) {
        uLongf destLen = output.size();
        int res = uncompress(
            reinterpret_cast<Bytef*>(output.data()), &destLen,
            reinterpret_cast<const Bytef*>(input.data()), input.size()
        );

        if (res == Z_OK) {
            output.resize(destLen); // Shrink buffer to actual decompressed size
            return true;
        }

        if (res == Z_BUF_ERROR) {
            // Output buffer was too small. Double it and try again.
            if (output.size() > 10 * 1024 * 1024) return false; // Safety break for huge files
            output.resize(output.size() * 2);
        } else {
            // Some other zlib error occurred
            return false;
        }
    }
}

bool compressZlib(std::span<const std::byte> input, std::vector<std::byte>& output) {
    uLong sourceLen = input.size();
    uLong destLen = compressBound(sourceLen);
    output.resize(destLen);

    int result = compress(
        reinterpret_cast<Bytef*>(output.data()), &destLen,
        reinterpret_cast<const Bytef*>(input.data()), sourceLen
    );

    if (result != Z_OK) {
        return false;
    }

    output.resize(destLen); // Shrink buffer to actual compressed size
    return true;
}

